---
title: "Ibex Manuscript Analysis"
author: "Nick Borcherding"
date: "5/13/2022"
output: html_document
---
# Getting Started

## Loading Libraries
```{r}
suppressPackageStartupMessages({
    library(Seurat)
    library(ggplot2)
    library(dplyr)
    library(gridExtra)
    library(viridis)
    library(RColorBrewer)
    library(Matrix)
    library(stringr)
    library(Ibex)
    library(mumosa)
    library(patchwork)
    library(ggthemes)
    library(FastKNN)
})
```
## Loading Pythong and Functions
```{r}
library(reticulate)
use_condaenv(condaenv = "r-reticulate", required = TRUE)
source("./R/utils.R")
source("./R/auto.encoder.R")
```

# Ibex performance on naive repertoire

## Loading BCR sequences 

BCR sequences being loaded are sequences never seen by the autoencoder. The R folder contains stripped down version of the Ibex encoders to allow for the comparisons without the need for single-cell data.

```{r, eval=FALSE}
#CDR3 sequences that the autoencoders have never seen before
unique.heavy <- readRDS("./data/naive.heavy.rds")
unique.light <- readRDS("./data/naive.light.rds")


######################
#Setting up the loops
#####################
#Testing both chains, 3 AA property encoders, testing time for chains, and bootstrapping everything together
set.seed(42)
chain.list <- list(unique.heavy, unique.light)
names(chain.list) <- c("Heavy", "Light")
num.chains <- c(10,100,1000,10000,100000)
boot.straps <- 1:5
AA.list <- c("KF", "AF", "OHE")


int.output <- NULL
for(i in seq_along(chain.list)) {
    for(j in seq_along(num.chains)) {
      tmp.chain <- chain.list[[i]][sample(length(chain.list[[i]]), num.chains[j])]
      for(k in seq_along(boot.straps)) {
        for(l in seq_along(AA.list)) {
          start_time <- Sys.time()
          out.tmp <- auto.encoder(tmp.chain, 
                         chain = names(chain.list)[i], 
                         AA.properties = AA.list[l])
          end_time <- Sys.time()
          runtime <- end_time - start_time
          out <- c(nrow(unique(out.tmp)), runtime, names(chain.list)[i], AA.list[l], num.chains[j], boot.straps[k])
          int.output <- rbind(int.output, out)
        }
      }
      colnames(int.output) <- c("unique.cdr3", "runtime", "chain", "property", "num.cdr3.tested", "boot.strap")
      rownames(int.output) <- NULL
      saveRDS(int.output, paste0("./metrics/", names(chain.list)[i], "_num.", num.chains[j], "_bs.", boot.straps[k], ".rds"))
    }
}
```


## Graphing the Benchmarking results

```{r}
final.output <- list.files("./metrics", full.names = TRUE)
final.output <- lapply(final.output, readRDS)
final.output <- do.call(rbind, final.output) %>%
  as.data.frame()


plot1 <- ggplot(final.output, aes(x = as.numeric(num.cdr3.tested), y = as.numeric(unique.cdr3), group = interaction(as.numeric(num.cdr3.tested),property))) + 
  geom_smooth(method = "lm", color = "black", size = 0.5) + 
  geom_jitter(aes(color = property)) + 
  scale_x_log10() + 
  scale_y_log10() + 
  xlab("cdr3 sequences tested") + 
  ylab("unique encoded values") + 
  scale_color_viridis(discrete = TRUE)+
  facet_grid(.~chain) + 
  theme_bw()

plot2 <- ggplot(final.output, aes(x = as.numeric(num.cdr3.tested), y = as.numeric(runtime), group = property)) + 
  geom_smooth(method = "loess", size = 0.5, aes(color = property)) + 
  geom_point(aes(color = property)) + 
   xlab("cdr3 sequences tested") + 
  ylab("time (s)") + 
  scale_x_log10() + 
  scale_color_viridis(discrete = TRUE)+
  facet_grid(.~chain) + 
  theme_bw()

plot1 + plot2 + plot_layout(ncol = 1)
ggsave("./output/benchmarking.pdf", height = 7, width = 7)
```


# The Data Set

To show the multiple options of Ibex, the example data is derived from [this manuscript (https://pubmed.ncbi.nlm.nih.gov/33891889/) - multimodal single-cell characterization of COVID-19-associated multisystem inflammatory syndrome in children. The data example built into the package (ibex_example) is derived from randomly sampling cells from Patient 1. For the manuscript, we incorporate several additional samples but focus on Patient 1, Patient 2, Healthy Donor 1, and Healthy Donor 4. The clonotype reduction is performed only on Patients 1 and , as these are the only MIS patients with GEX + ADT + TCR sequencing. 

## Preprocessing Data

```{r, eval=FALSE}
dir.create("./qc")
GEX.matrices <- list.dirs("./data/sequencingRuns", 
                           recursive = TRUE,
                           full.names = TRUE)
GEX.matrices <- GEX.matrices[grep("filtered_feature_bc_matrix", GEX.matrices)]
sample.names <- list.dirs("./data/sequencingRuns", recursive = FALSE)
sample.names <- stringr::str_split(sample.names, "[/]", simplify = TRUE)[,4]

seurat.list <- NULL
for(i in seq_along(sample.names)) {
  tmp <- Read10X(GEX.matrices[[i]])
  if(length(tmp) == 2) {
     s.object <- CreateSeuratObject(counts = tmp$`Gene Expression`, sample.names[i])
     #Removing extra prefixes on antibodies
     rownames(tmp$`Antibody Capture`) <- stringr::str_remove_all(rownames(tmp$`Antibody Capture`), "anti_human_")
     rownames(tmp$`Antibody Capture`) <- stringr::str_remove_all(rownames(tmp$`Antibody Capture`), "anti_mousehuman_")
     rownames(tmp$`Antibody Capture`) <- substr(rownames(tmp$`Antibody Capture`), 6, nchar(rownames(tmp$`Antibody Capture`)))
  
     adt_assay <- CreateAssayObject(counts = tmp$`Antibody Capture`)
     s.object[["ADT"]] <- adt_assay
  } else {
    s.object <- CreateSeuratObject(counts = tmp, project = sample.names[i])
  }
  s.object <- RenameCells(object = s.object , new.names = paste0(sample.names[i], "_", rownames(s.object[[]])))
  s.object <- subset(s.object, subset = nFeature_RNA > 100) 
  s.object[["percent.mt"]] <- PercentageFeatureSet(s.object, pattern = "^MT-")
  s.object[["percent.rb"]] <- PercentageFeatureSet(s.object, pattern = "^RBS|RPL")
  
  p1 <- VlnPlot(object = s.object, features = c("nCount_RNA")) + theme(legend.position = "none")
  p2 <- VlnPlot(object = s.object, features = c("nFeature_RNA")) + theme(legend.position = "none")
  p3 <- VlnPlot(object = s.object, features = c("percent.mt")) + theme(legend.position = "none")
    
  
  p1 + p2 + p3+ plot_layout(ncol = 3)
  ggsave(paste0("./qc/", sample.names[i], ".pdf"), height = 8, width=12)
    
  ###########################
  #Here is the filtering step
  ############################
  standev <- sd(log(s.object$nCount_RNA))*2 #cutting off above standard deviation of 2
  mean <- mean(log(s.object$nCount_RNA))
  cut <- round(exp(standev+mean))
  s.object <- subset(s.object, subset = percent.mt < 15 & nFeature_RNA < cut)

  seurat.list[[i]] <- s.object
}

seurat.merge <- merge(seurat.list[[1]], seurat.list[-1])


###########################
#Adding Contig Information
############################
  
contig.file <- list.files("./data/sequencingRuns/", 
                            pattern = "contig", 
                            full.names = TRUE, 
                            recursive = TRUE)

contigs <- lapply(contig.file, read.csv)
clones <- combineBCR(contigs, samples = sample.names, removeNA = TRUE)
seurat.merge <- combineExpression(clones, seurat.merge, cloneCall = "aa")
seurat.merge$BCR.recoverd <- "No"
seurat.merge$BCR.recoverd[!is.na(seurat.merge$CTaa)] <- "Yes"
seurat.merge <- subset(seurat.merge, BCR.recoverd == "Yes")
saveRDS(seurat.merge, "./data/Ibex_SCdata.rds")

###########################
#Integration Step
############################
#Only fraction has ADT - we will just do overall RNA for now.
"%!in%" <- Negate("%in%")
seurat.merge <- readRDS("./data/Ibex_SCdata.rds")
seurat.list <- SplitObject(seurat.merge, split.by = "orig.ident")
seurat.list <- lapply(X = seurat.list, function(x) {
  trans <- SCTransform(x,
                        vars.to.regress = c('percent.mt', 'percent.rb', "nCount_RNA"),
                        min_cells = 3, 
                        verbose = FALSE)
  trans
})
features <- SelectIntegrationFeatures(object.list = seurat.list, nfeatures = 3000)
features <- Ibex::quietBCRgenes(features)
seurat.list <- PrepSCTIntegration(object.list = seurat.list, anchor.features = features)

immune.anchors <- FindIntegrationAnchors(object.list = seurat.list, normalization.method = "SCT", anchor.features = features)
seurat.merge <- IntegrateData(anchorset = immune.anchors, normalization.method = "SCT")
seurat.merge <- RunPCA(seurat.merge, verbose = FALSE)
seurat.merge <- RunUMAP(seurat.merge, reduction = "pca", dims = 1:30)
saveRDS(seurat.merge, "./data/Ibex_SCdata.rds")
```

## Adding meta data
```{r}
dir.create("./output")

seurat.merge <- readRDS("./data/Ibex_SCdata.rds")

seurat.merge$status <- ifelse(seurat.merge$orig.ident %in% c("HD1", "HD2", "HD3", "HD4", "HD5"), "Healthy", "MIS")

############################
#Adding genes to meta data
###########################

seurat.merge$Heavy.V <- str_split(seurat.merge$CTgene, "[.]", simplify = TRUE)[,1]
seurat.merge$Light.V <- str_split(str_split(seurat.merge$CTgene, "[_]", simplify = TRUE)[,2], "[.]", simplify = TRUE)[,1]
seurat.merge$Heavy.C <- str_split(str_split(seurat.merge$CTgene, "[.]", simplify = TRUE)[,4], "[_]", simplify = TRUE)[,1]
seurat.merge$Light.C <- str_split(str_split(seurat.merge$CTgene, "[_]", simplify = TRUE)[,2], "[.]", simplify = TRUE)[,3]
```

# Running Autoencoders using Ibex
```{r}
##################
#Running Ibex
################
seurat.merge  <- runIbex(seurat.merge, 
                    chains = "Heavy",
                    AA.properties = "KF", 
                    reduction.name = "Ibex.H.KF")

seurat.merge  <- runIbex(seurat.merge, 
                    chains = "Light",
                    AA.properties = "KF", 
                    reduction.name = "Ibex.L.KF")

seurat.merge  <- runIbex(seurat.merge, 
                    chains = "Heavy",
                    AA.properties = "AF", 
                    reduction.name = "Ibex.H.AF")

seurat.merge  <- runIbex(seurat.merge, 
                    chains = "Light",
                    AA.properties = "AF", 
                    reduction.name = "Ibex.L.AF")

seurat.merge  <- runIbex(seurat.merge, 
                    chains = "Heavy",
                    AA.properties = "OHE", 
                    reduction.name = "Ibex.H.OHE")

seurat.merge  <- runIbex(seurat.merge, 
                    chains = "Light",
                    AA.properties = "OHE", 
                    reduction.name = "Ibex.L.OHE")



saveRDS(seurat.merge, "./data/Ibex_SCdata.rds")
```

# Plotting MDS of Latent Dimensions

```{r}
cells <- which(seurat.merge[[]]$orig.ident %in% c("P1.1", "P2.1", "HD1", "HD4"))
heavy <- c("Ibex.H.KF", "Ibex.H.AF","Ibex.H.OHE")
light <- c("Ibex.L.KF", "Ibex.L.AF","Ibex.L.OHE")
    
for (j in seq_along(heavy)) {
        tmp <- subset(seurat.merge, cells = rownames(seurat.merge[[]])[cells])
        
        #Calculate MDS   
        d <- dist(tmp@reductions[[heavy[j]]]@cell.embeddings)
        mds <- cmdscale(d = d, k = 2)
        colnames(mds) <- paste0("MDS_", 1:2)
        tmp[["mds"]] <- CreateDimReducObject(embeddings = mds, key = "MDS_", assay = DefaultAssay(tmp))
         
        MDS.plot.H <- DimPlot(tmp, reduction = "mds", group.by = "Heavy.V") + 
                          scale_color_viridis(discrete = TRUE) + 
                          theme_void() + 
                          guides(fill = "none") + 
                          theme(plot.title = element_blank()) +
                          NoLegend() 
        
         MDS.plot.Ident <- DimPlot(tmp, reduction = "mds", group.by = "orig.ident") + 
                              scale_color_viridis(discrete = TRUE) + 
                              theme_void() + 
                              guides(fill = "none") + 
                              theme(plot.title = element_blank())
         
         MDS.plot.Heavy <- DimPlot(tmp, reduction = "mds", group.by = "Heavy.C") + 
                              scale_color_viridis(discrete = TRUE) + 
                              theme_void() + 
                              guides(fill = "none") + 
                              theme(plot.title = element_blank())
         
         tmp$Heavy.length <- nchar(stringr::str_split(tmp$CTaa, "_", simplify = TRUE)[,1])
         
         MDS.plot.HeavyL <- FeaturePlot(tmp, reduction = "mds", features = "Heavy.length") + 
                              scale_color_viridis() + 
                              theme_void() + 
                              guides(fill = "none") + 
                              theme(plot.title = element_blank())
         
          
         
         MDS.plot.Ident + MDS.plot.HeavyL + MDS.plot.H + MDS.plot.Heavy + plot_layout(ncol = 2)
    ggsave(paste0("./output/", heavy[j], "_", paste0(c("P1.1", "P2.1", "HD1", "HD4"), collapse = "."), "_MDS.png"), height = 8, width = 8, dpi = 600)
    if (heavy[j] == "Ibex.H.KF") {
        
            ggsave( paste0("./output/", heavy[j], "_", paste0(c("P1.1", "P2.1", "HD1", "HD4"), collapse = "."),
                           "_Heavy.Vchain.png"), 
                    MDS.plot.H, height = 4, width = 4, dpi = 600)
    }
}
    
for (k in seq_along(light)) {
        tmp <- subset(seurat.merge, cells = rownames(seurat.merge[[]])[cells])
        
        #Calculate MDS  
        d <- dist(tmp@reductions[[light[k]]]@cell.embeddings)
        mds <- cmdscale(d = d, k = 2)
        colnames(mds) <- paste0("MDS_", 1:2)
        tmp[["mds"]] <- CreateDimReducObject(embeddings = mds, key = "MDS_", assay = DefaultAssay(tmp))
        
         
        MDS.plot.H <- DimPlot(tmp, reduction = "mds", group.by = "Light.V") + 
                          scale_color_viridis(discrete = TRUE) + 
                          theme_void() + 
                          guides(fill = "none") + 
                          theme(plot.title = element_blank()) +
                          NoLegend()
        
         MDS.plot.Ident <- DimPlot(tmp, reduction = "mds", group.by = "orig.ident") + 
                              scale_color_viridis(discrete = TRUE) + 
                              theme_void() + 
                              guides(fill = "none") + 
                              theme(plot.title = element_blank())
         
         MDS.plot.Light <- DimPlot(tmp, reduction = "mds", group.by = "Light.C") + 
                              scale_color_viridis(discrete = TRUE) + 
                              theme_void() + 
                              guides(fill = "none") + 
                              theme(plot.title = element_blank())
         
         tmp$Light.length <- nchar(stringr::str_split(tmp$CTaa, "_", simplify = TRUE)[,2])
         
         MDS.plot.LightL <- FeaturePlot(tmp, reduction = "mds", features = "Light.length") + 
                              scale_color_viridis() + 
                              theme_void() + 
                              guides(fill = "none") + 
                              theme(plot.title = element_blank())
         
         Dim.plot.LightL <- FeaturePlot(tmp, reduction = light[k], features = "Light.length") + 
                              scale_color_viridis() + 
                              theme_void() + 
                              guides(fill = "none") + 
                              theme(plot.title = element_blank())
         
         
         MDS.plot.Ident + MDS.plot.LightL + MDS.plot.H + MDS.plot.Light + plot_layout(ncol = 2)
    ggsave(paste0("./output/", light[k], "_", paste0(c("P1.1", "P2.1", "HD1", "HD4"), collapse = "."), "_MDS.png"), height = 8, width = 8)
        if (light[k] == "Ibex.L.KF") {
            ggsave(paste0("./output/", heavy[j], "_", paste0(c("P1.1", "P2.1", "HD1", "HD4"), collapse = "."), "_light.Vchain.png"),
                   MDS.plot.H,
                   height = 4, width = 4, dpi = 600)
    }
}
```

# Reducing the data set to clonotypes

We are selecting only the P1.1 and P2.1 samples as they have GEX, ADT, and TCR sequencing.

```{r}
cells <- which(seurat.merge[[]]$orig.ident %in% c("P1.1", "P2.1"))

subset.Obj <- subset(seurat.merge, cells = rownames(seurat.merge[[]][cells,])) 

subset.Obj <- RunPCA(subset.Obj, verbose = FALSE)

subset.Obj <- NormalizeData(subset.Obj, assay = "ADT", normalization.method = 'CLR', margin = 2) 
IG.ADT <- grep("Ig",  rownames(subset.Obj[["ADT"]]))
VariableFeatures(subset.Obj, assay = "ADT") <- rownames(subset.Obj[["ADT"]])[-IG.ADT] #Removing Immunoglobulins from DimRed
subset.Obj <- ScaleData(subset.Obj, assay = "ADT")
subset.Obj <- RunPCA(subset.Obj, reduction.name = 'apca', assay = "ADT")

conga <- CoNGAfy(subset.Obj, 
                 assay = c("RNA", "ADT"))

#Get count of number of clones
meta <- seurat.merge[[]]
clone.count <- meta %>%
  group_by(CTaa) %>%
  summarise(n = n()) %>%
  as.data.frame()

ID <- clone.count$CTaa
clone.count <- data.frame(n = clone.count[,2])
rownames(clone.count) <- ID
conga <- AddMetaData(conga, clone.count)

#Getting the meta data reattached
meta <- subset.Obj[[]]
CTaa.unique <- unique(meta$CTaa)
for(i in seq_along(CTaa.unique)) {
  meta.tmp <- meta[meta$CTaa == CTaa.unique[i],]
  CTaa.tmp <- c(CTaa = unique(meta.tmp$CTaa), 
                donor = (paste(str_sort(unique(meta.tmp$orig.ident)), collapse = ";")), 
                H.V = paste(str_sort(unique(meta.tmp$Heavy.V)), collapse = ";"), 
                H.C = paste(str_sort(unique(meta.tmp$Heavy.C)), collapse = ";"), 
                L.V = paste(str_sort(unique(meta.tmp$Light.V)), collapse = ";"), 
                L.C = paste(str_sort(unique(meta.tmp$Light.C)), collapse = ";"))
  if(i == 1) {
    CTaa.Library <- CTaa.tmp
  } else {
    CTaa.Library <- rbind(CTaa.Library, CTaa.tmp)
  }
}
CTaa.Library <- as.data.frame(CTaa.Library)
aa <- CTaa.Library$CTaa
CTaa.Library <- CTaa.Library[,-1]
rownames(CTaa.Library) <- aa
colnames(CTaa.Library)[5] <- c("Light.C")

conga <- AddMetaData(conga, CTaa.Library)

DefaultAssay(conga) <- 'RNA'
conga <- NormalizeData(conga) %>% 
  FindVariableFeatures() %>% 
  quietBCRgenes() %>% 
  ScaleData() %>% 
  RunPCA(verbose = FALSE)

#Processing ADT
DefaultAssay(conga) <- 'ADT'
IG.ADT <- grep("Ig",  rownames(conga[["ADT"]]))
VariableFeatures(conga) <- rownames(conga[["ADT"]])[-IG.ADT] #Removing Immunoglobulins from DimRed

conga <- NormalizeData(conga, normalization.method = 'CLR', margin = 2) %>% 
  ScaleData() %>% 
  RunPCA(reduction.name = 'apca')

##################
#Running Ibex
################
conga <- runIbex(conga, 
                    chains = "Heavy",
                    AA.properties = "KF", 
                    reduction.name = "Ibex.H.KF")

conga <- runIbex(conga, 
                    chains = "Light",
                    AA.properties = "KF", 
                    reduction.name = "Ibex.L.KF")

###################
#Trimodal Embedding
###################
output <- rescaleByNeighbors(
                  list(conga[["Ibex.H.KF"]]@cell.embeddings, 
                      conga[["pca"]]@cell.embeddings, 
                      conga[["apca"]]@cell.embeddings), 
                  k = 50)

conga[["Trimodal.Embed"]] <- CreateDimReducObject(
                                embeddings = as.matrix(output),
                                stdev = rep(0, ncol(output)),
                                key = "Combined",
                                jackstraw = NULL,
                                misc = list())

conga <- FindNeighbors(conga, 
                       reduction = "Trimodal.Embed", 
                       dims = 1:130, 
                       graph.name = c("Ibex_nn", "Ibex_snn"))
conga <- FindClusters(conga,
                      graph.name = "Ibex_snn",
                      algorithm = 4)

#######################################
#UMAP Comparisons between each approach
#######################################

conga <- RunUMAP(conga, 
                     reduction = 'pca', 
                     dims = 1:30, 
                     assay = 'RNA', 
                     reduction.name = 'rna.umap', 
                     reduction.key = 'rnaUMAP_')

conga <- RunUMAP(conga, 
                     reduction = 'apca', 
                     dims = 1:30, 
                     assay = 'ADT', 
                     reduction.name = 'adt.umap', 
                     reduction.key = 'adtUMAP_')

conga <- RunUMAP(conga, 
                     reduction = 'Ibex.H.KF', 
                     dims = 1:30, 
                     reduction.name = 'heavy.umap', 
                     reduction.key = 'heavyUMAP_')

conga <- RunUMAP(conga, 
                     reduction = 'Ibex.L.KF', 
                     dims = 1:30, 
                     reduction.name = 'light.umap', 
                     reduction.key = 'lightUMAP_')

conga <- RunUMAP(conga, 
                     reduction = 'Trimodal.Embed', 
                     dims = 1:130, 
                     reduction.name = 'trimodal.umap', 
                     reduction.key = 'trimodalUMAP_')

saveRDS(conga, file = "./data/Ibex_ClonotypeRep.rds")
```

## Plotting dimensional reduction for individual clonotypes

```{r}
conga <- readRDS("./data/Ibex_ClonotypeRep.rds")
plot.rna <- DimPlot(conga, reduction = "rna.umap") + NoLegend()
plot.adt <- DimPlot(conga, reduction = "adt.umap") + NoLegend()
plot.heavy <- DimPlot(conga, reduction = "heavy.umap") + NoLegend()
plot.combined <- DimPlot(conga, reduction = "trimodal.umap") + NoLegend()

###############
#Plotting
#############

plot.rna + 
  scale_color_tableau() + 
  theme_void() + 
  NoLegend()
ggsave("./output/clonotype_RNA_umap.pdf", height = 3.5, width = 3.5)

plot.adt + 
  scale_color_tableau() + 
  theme_void() + 
  NoLegend()
ggsave("./output/clonotype_ADT_umap.pdf", height = 3.5, width = 3.5)

plot.heavy + 
  scale_color_tableau() + 
  theme_void() + 
  NoLegend()
ggsave("./output/clonotype_IgHeavy_umap.pdf", height = 3.5, width = 3.5)

plot.combined + 
  scale_color_tableau() + 
  theme_void() + 
  NoLegend()
ggsave("./output/clonotype_combined_umap.pdf", height = 3.5, width = 3.5)

CD45.plot <- FeaturePlot(conga, 
                 reduction = "trimodal.umap", 
                 features = c("CD45RA", "CD45RO"), 
                 cols = viridis_pal()(50), 
                 combine = FALSE) 

for(i in seq_along(CD45.plot)) {
  CD45.plot[[i]] <- CD45.plot[[i]] + 
              guides(color = "none") + 
              theme_void() + 
              theme(plot.title = element_blank(), 
                    plot.margin = unit(c(0.6, 0.15, 0.6, 0.15), "cm"))
}
plot_a_list(CD45.plot,2,1)
ggsave("./output/combined_CD45plots.png", height = 10, width = 5, dpi = 600)

saveRDS(conga, file = "./data/Ibex_ClonotypeRep.rds")
```

# Comparing outputs to the Benisse pipeline

The combination of gene expression and cdr3 sequence encoding for B cell receptors is a relatively new concept, but there exist an alternative pipeline for heavy chain + expression embedding, called [Benisse](https://github.com/wooyongc/Benisse) with the accompanying [manuscript](https://www.nature.com/articles/s42256-022-00492-6). In order to benchmark our approach, below is the code for the integration and visualization of both outputs for Patient 1 and Patient 2. The Benisse pipeline outputs are available in the *./data/Benisse*.

## Loading and combining data 

```{r}
load("./data/Benisse/PT1.1/Benisse_results.RData")
Ben.P1 <- results

load("./data/Benisse/PT2.1/Benisse_results.RData")
Ben.P2 <- results

conga$Heavy <- str_split(conga$CTaa, "_", simplify = TRUE)[,1]
conga.P1 <- subset(conga, donor == "P1.1")
conga.P2 <- subset(conga, donor == "P2.1")
```

## Integrating the two pipelines
```{r}
conga.list <- list(conga.P1, conga.P2)
ben.list <- list(Ben.P1, Ben.P2)

for (i in 1:2) {
  distMatrix <- ben.list[[i]]$master_dist_e
  
  # matrix of neighbours from Benisse
  k=20
  n = nrow(distMatrix)
  nn = matrix(0,n,k) # n x k
  for (x in 1:n) {
     nn[x,] = k.nearest.neighbors(x, distMatrix, k = k)
  }
  rownames(nn) <- ben.list[[i]]$meta_dedup$cdr3
  
  conga.tmp <- subset(conga.list[[i]], cells = rownames(conga.list[[i]]@meta.data)[conga.list[[i]]$Heavy %in% rownames(nn)])
  
  meta <- conga.tmp[[]]
  ben.meta <-  ben.list[[i]]$meta_dedup
  meta <- merge(meta, ben.meta, by.x = "Heavy", by.y = "cdr3")
  clones <- meta$CTaa
  if(any(duplicated(clones))) {
    meta <- meta[-which(duplicated(clones)),]
    clones <- clones[-which(duplicated(clones))]
  }
  rownames(meta) <- clones
  conga.tmp <- AddMetaData(conga.tmp, meta)


  #Generating a GEX + BCR comparison
  output <- rescaleByNeighbors(
                    list(conga.tmp[["Ibex.H.KF"]]@cell.embeddings, 
                        conga.tmp[["pca"]]@cell.embeddings),
                        k = 50)
  
  conga.tmp[["Bimodal.Embed"]] <- CreateDimReducObject(
                                  embeddings = as.matrix(output),
                                  stdev = rep(0, ncol(output)),
                                  key = "Combined",
                                  jackstraw = NULL,
                                  misc = list())
  
  conga.tmp <- FindNeighbors(conga.tmp, 
                         reduction = "Bimodal.Embed", 
                         dims = 1:80, 
                         graph.name = c("Ibex_nn", "Ibex_snn"))
  conga.tmp <- FindClusters(conga.tmp,
                        graph.name = "Ibex_nn",
                        algorithm = 4)
  conga.tmp <- RunUMAP(conga.tmp, assay = "RNA", dims = 1:30)
  
  df <- conga.tmp[[]]
  
  bar.plot <- ggplot(df, aes(x=seurat_clusters, fill = as.factor(cluster))) + 
                geom_bar(position = "fill", color = "black") + 
                scale_fill_viridis(discrete = TRUE, na.value = "grey", option = "H") + 
                guides(fill = "none") + 
                coord_flip() + 
                ylab("Proportion") + 
                xlab("Ibex RNA + BCR Clusters") + 
                theme_bw()
  
  
    breakdown <- bluster::pairwiseRand(ref=df$seurat_clusters, alt=df$Ibex_snn_res.0.8, mode="ratio")
    breakdown <- reshape2::melt(breakdown)
    
    ARI <- ggplot(breakdown, aes(x= as.factor(Var1), y = as.factor(Var2), fill = value)) + 
      geom_tile(color = "black") + 
      theme_classic() + 
      labs(fill="ARI") + 
      scale_fill_viridis(na.value = "white")+
      theme(axis.title = element_blank(), 
            axis.ticks = element_blank(),)
  
  
  Ben.cluster <- DimPlot(conga.tmp, group.by = "cluster", reduction = "umap") +
                    scale_color_viridis(option = "H", discrete = TRUE, na.value = "grey") + 
                    theme_void()+
                    NoLegend() + 
                    theme(plot.title = element_blank())

  Ibex.cluster <- DimPlot(conga.tmp, group.by = "seurat_clusters", reduction = "umap") + 
                    scale_color_viridis(option = "H", discrete = TRUE, na.value = "grey") +
                    theme_void()+
                    NoLegend() + 
                    theme(plot.title = element_blank())



  neighbor.output <- NULL
  for (y in seq_len(nrow(nn))) {
    if (rownames(nn)[y] %in% conga.tmp$Heavy) {
      ben.nn <- rownames(nn)[nn[y,]]
      clone.pos <- which(rownames(nn)[y] == conga.tmp$Heavy)
      conga.pos <- which(conga.tmp@graphs$Ibex_nn[clone.pos,] > 0)
      conga.nn <- conga.tmp$Heavy[conga.pos]
      intersect <- length(intersect(ben.nn, conga.nn))
      neighbor.output <- rbind(neighbor.output, c(rownames(nn)[y], intersect, length(unique(conga.nn)), length(unique(ben.nn))))
    } else {
      next()
    }
  }
  neighbor.output <- as.data.frame(neighbor.output)
  colnames(neighbor.output) <- c("Heavy", "Overlap", "Ibex", "Ben")
  df <- merge(df, neighbor.output, by = "Heavy")
  df$Jaccard <- as.numeric(df$Overlap)/(as.numeric(df$Ibex) + as.numeric(df$Ben))
  df$Dice <- (2 * as.numeric(df$Overlap))/(as.numeric(df$Ibex) + as.numeric(df$Ben))

  JI.plot <- ggplot(df, aes(x=1, y = Jaccard)) + 
                geom_boxplot() + 
                ylim(0, 0.5) + 
                ylab("Jaccard Index") + 
                coord_fixed() + 
                coord_flip() + 
                theme_bw() + 
                theme(axis.title.y = element_blank(), 
                      axis.ticks.y = element_blank(), 
                      axis.text.y = element_blank())

  DI.plot <- ggplot(df, aes(x=1, y = Dice)) + 
                geom_boxplot() + 
                ylim(0, 0.5) + 
                ylab("SÃ¸rensen/Dice Index") + 
                coord_fixed() + 
                coord_flip() + 
                theme_bw() + 
                theme(axis.title.y = element_blank(), 
                      axis.ticks.y = element_blank(), 
                      axis.text.y = element_blank())


  x <- bar.plot / ARI + {
      JI.plot / DI.plot + 
      plot_layout(ncol=1)
    }

 ((Ben.cluster + Ibex.cluster  + plot_layout(ncol = 1)) | x)  + 
    plot_layout(widths = c(2,1))
  ggsave(paste0("./output/Patient", i, "BenisseComparison.pdf"), height = 10, width = 10)
}

 
 
```

# Conclusions

```{r}
sessionInfo()
```


